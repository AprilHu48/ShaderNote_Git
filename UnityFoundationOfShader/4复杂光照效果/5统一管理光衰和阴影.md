我们已经知道如何在 Unity Shader 的前向渲染路径中计算光照衰减 在 Base Pass 中,平行光的衰减因子总是等于1,而在Additional Pass 中,我们需要判断该 Pass 处理的光源类型,再使用内置变量和宏计算衰减因子。实际上,光照衰减和阴影对物体最终的渲染结果的影响本质上是相同的——我们都是把光照衰减因子和阴影值及光照结果相乘得到最终的渲染结果。

所以Unity 在 Shader 里提供了內置的宏:(UNITY_LIGHT_ATTENUATION ),来同时计算光照衰减因子和阴影值

我们打开Chapter9-AttenuationAndShadowUseBuildInFunctions:

(1)其引用了两个头文件调用内置方法

```
#include "Lighting.cginc"
#include "AutoLight.cginc"
```

(2)在v2f结构体中使用内置宏 SHADOW_COORDS 声明阴影坐标:

```
struct v2f {
		float4 pos : SV_POSITION;
		float3 worldNormal : TEXCOORD0;
		float3 worldPos : TEXCOORD1;
		SHADOW_COORDS(2)
};
```

(3))在顶点着色器中使用内置宏 TRANSFER_SHADOW 计算并向片元着色器传递阴影坐标:

```
v2f vert(a2v v) {
	v2f o;
	o.pos = UnityObjectToClipPos(v.vertex);
			 	
	o.worldNormal = UnityObjectToWorldNormal(v.normal);

	o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
			 	
	// Pass shadow coordinates to pixel shader
	TRANSFER_SHADOW(o);
			 	
	return o;
}
```

(4)在片元着色器中使用内置宏 UNITY_LIGHT_ ATTENUATION 来计算光照衰减和阴影:

```
fixed4 frag(v2f i) : SV_Target {
	...
	// UNITY_LIGHT_ATTENUATION not only compute attenuation, but also shadow infos
	UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);
			 	
	return fixed4((diffuse + specular) * atten, 1.0);
}
```

UNITY_LIGHT_ATTENUATION 是 Unity 内置的用于计算光照衰减和阴影的宏,我们可以 在内置的 AutoLight.cginc 里找到它的相关声明。

**注意**,我们并没有在代码中声明第一个参数 atten,这是因为 UNITY_ LIGHT_ATTENUATION会帮我们声明这个变量。

第二个参数是结构体 v2f,这个 参数会传递给9.4.2节中使用的SHADOW_ATTENUATION,用来计算阴影值.

第三个参数是 世界空间的坐标,正如我们在9.3 节中看到的一样,这个参数会用于计算光源空间下的坐标,再 对光照衰减纹理采样来得到光照衰减。

(5)使用 UNITY_LIGHT_ATTENUATION,我们的 Base Pass 和 Additional Pass 的代 码得以统一,我们不需要在 Base Pass 里单独处理阴影,也不需要在 Additional Pass 中判断光源类型来处理光照衰减,一切都只需要通过 UNITY_LIGHT_ATTENUATION来完成即可。

如果我们希望可以在 Additional Pass 中添加阴影效果,就需要使用 #pragma multi_compile_fwdadd_fullshadows 编译指令来代替 Additional Pass 中的#pragma multi_compile_fwdadd 指令。这样一来,Unity 也会为这些额外的逐像素光源计算阴影,并传递给 Shader.